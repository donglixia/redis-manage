##redis分布式锁
redis分布式锁需要考虑的几个问题
1.使用setnx ,结束时需要删掉锁(删除锁)
2.中间可能程序抛异常，锁需要在finally中执行删除锁（删除锁一定要执行）
3.先查询锁存在再删除锁，两个操作必须是原子操作，不然多线程中，一个刚查到，cpu又被另一个占用，前一个可能会把后一个锁删除（必须查询到锁，并且锁是自己的）
4.删除锁必须只能删除自己的，所以给这个锁一个唯一值，删除锁之前要比较这个值
5.可能redis挂了，所以锁必须要设置有效时间，否则永远无法解锁（必须设置有效时间）
6.有效时间大小不好判断，有可能中间执行时间过长导致锁失效，可以看门狗，定时任务去给锁续时间（有效时间可能过期，并且设置锁和设置有效期时间必须位原子操作）
（redisson中实现了，这些逻辑，比如查询 锁存在并设置锁 判断锁并删除锁 ，这些都需要原子操作，里面使用的lua命令，并且时间了定时任务去刷新有效时间，延迟1/3）
7.锁考虑可重入

分布式锁这样其实是串行化了并发执行，效率可能会比较低
优化提高分布式锁性能
参考分段锁（concurrentHashMap）
如200个商品，分段，给10段，每段20个商品，这样就提升了10倍

还存在问题，redis集群，异步的复制，可能你给一个节点加锁了，然后没有同步到其他节点，挂掉了，其他线程在其他的节点
上又加上锁了

解决思想  redlock（红锁），redisson包已经有对redlock算法封装
多个master，超半数加锁成功，才算成功,通过其他的方式加锁 比如数据库锁select for update（考虑线程池有事务并且事务必须提交）

3.redis分布式锁需要考虑的其他问题
 (1) 设置键时,键资源从哪获取
 其中涉及多客户端的资源共识问题,简单的分析就是,你怎么确定在多个客户端对同一资源进行加锁操作的时候,这个键(key)就需要多个客户端一致,否则,我怎么保证键在多个客户端的唯一性呢.         
 (2) 释放锁时只能由拥有锁资源的客户端释放         
 当然,这个问题是由于你加锁和解锁逻辑写的不对的情况.根据上面分析,只要解决上面所有对redis分布式锁的所有问题,这个客户端锁释放的问题一般碰不到.         
 不过,这也是细节问题,需要将该问题考虑在业务逻辑中
 例如: 
 (1) 设置键时,键资源从哪获取 
 其中涉及多客户端的资源共识问题,简单的分析就是,你怎么确定在多个客户端对同一资源进行加锁操作的时候,这个键(key)就需要多个客户端一致,否则,我怎么保证键在多个客户端的唯一性呢. 
 (2) 释放锁时只能由拥有锁资源的客户端释放 
 当然,这个问题是由于你加锁和解锁逻辑写的不对的情况.根据上面分析,只要解决上面所有对redis分布式锁的所有问题,这个客户端锁释放的问题一般碰不到.
 不过,这也是细节问题,需要将该问题考虑在业务逻辑中

--分布式锁选择
分布式系统中的cap原则（一致性，可用性，分区容错性）
redis ap 可用性，设置成功直接返回，异步复制，高并发还得选redis
zookeeper  cp 一致性 Zab协议（leader，fllow）树型结构，集群内扩散，超过半数，才返回成功（zookeeper课程）

zk实现分布式锁的问题

1. zk提交类似于一个2PC过程，设置锁的性能会低于redis
2. zk leader一旦挂掉，设置锁就不可用（相对而言redis多个master节点都可以写）
3. 状态处理不正确，容易出现多个客户端持有锁或者释放不掉
可扩展性不足，ZK集群不支持在线动态添加机器或替换机器
因为只有一个Leader，水平扩展并不能明显提升性能，因为只有1个Leader, zk机器节点越多，反而会导致通信和同步时间更长，性能可能会变差，zk集群的实际qps tps能力 是 几万 这个级别



分布式锁的问题
  锁需要具备唯一性
  锁需要有超时时间,防止死锁
  锁的创建和设置锁超时时间需要具备原子性
  锁的超时问题
  锁的可重入问题
  集群下分布式锁的问题
